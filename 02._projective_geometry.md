# üéì **Lecture 2: Projective Geometry**
*"How Computers See 3D in a Flat World!"*

---

## üß† **What‚Äôs the Big Idea?**
Ever taken a photo of a tall building and it looks like it‚Äôs **falling over**? Or tried to draw a road that **disappears into the distance**? That‚Äôs because cameras (and our eyes!) squish the **3D world** into **2D photos**. Projective geometry is the **math magic** that helps computers **unsquish** things and see depth even from flat images!

**Why‚Äôs this important?**
- Self-driving cars need to "see" how far away things are.
- Augmented reality (AR) apps (like Pok√©mon GO) need to place 3D objects in your camera view.
- Robots use it to **navigate** and **grab objects** without crashing.

---

## üöÇ **Analogy Time!**
Imagine you‚Äôre standing on a **train track** üöÇ. The tracks look like they **meet in the distance**, but we know they‚Äôre **parallel**. Projective geometry helps computers understand that **trick** just like your brain does!

Or think of a **movie projector** üé•. It takes a flat film and **stretches** it onto a screen to make it look 3D. Projective geometry does the **opposite**: it takes a flat photo and figures out what the **real 3D world** looked like.

---

## üîç **Key Concepts (The Math Magic!)**
### **Homogeneous Coordinates (Fancy Name for "Adding a Z Dimension")**
- In **2D**, a point is `(x, y)`.
- In **3D**, a point is `(x, y, z)`.
- In **projective geometry**, we add a **4th number** (usually `1`) to make it `(x, y, z, 1)`.
  - This lets us do **cool tricks** like rotating, scaling, and moving objects with **one equation**!

**Example:**
If you have a point `(2, 3)` in 2D, in homogeneous coordinates it‚Äôs `(2, 3, 1)`.

---

### **Perspective Projection (How Cameras "Lie")**
Cameras **squish** 3D points onto a 2D image. Here‚Äôs how:

1. **3D Point** ‚Üí `(X, Y, Z)` (real-world coordinates).
2. **Camera Matrix** ‚Üí A **magic box** of numbers that describes the camera‚Äôs position and lens.
3. **2D Point** ‚Üí `(x, y)` (where the point appears in the photo).

**Formula (Simplified):**
```
x = (X * f) / Z
y = (Y * f) / Z
```
- `f` = focal length (how "zoomed in" the camera is).
- `Z` = how far away the object is.

**What‚Äôs happening?**
- Far-away objects (`Z` is big) appear **smaller** in the photo.
- Close objects (`Z` is small) appear **bigger**.

**Fun Fact:**
This is why **train tracks look like they meet in the distance** the `Z` value makes them shrink!

---

### **3Ô∏è‚É£ Homography (The "Unsquish" Tool)**
A **homography** is a **3x3 matrix** that warps one image to match another. It‚Äôs like **stretching** a photo to fix perspective.

**When do we use it?**
- **Panoramas**: Stitching multiple photos together.
- **Augmented Reality**: Placing 3D objects in a 2D photo.
- **Document Scanning**: Fixing photos of receipts or whiteboards.

**Example:**
If you take a photo of a **tilted book**, a homography can **straighten it out** so it looks like you took the photo head-on.

---

## üöÄ **Let‚Äôs Get Hands-On!**
### **Install OpenCV (If You Haven‚Äôt Already)**
```bash
pip install opencv-python numpy matplotlib
```

---

### **ix a Tilted Photo (Like a Scanner App)**
Let‚Äôs use **homography** to fix a photo of a **tilted document**.

```python
import cv2
import numpy as np

# Load the image
image = cv2.imread("tilted_document.jpg")

# Define the 4 corners of the document in the image (manually or with mouse clicks)
# Format: [[x1, y1], [x2, y2], [x3, y3], [x4, y4]]
src_points = np.float32([[50, 50], [400, 50], [400, 500], [50, 500]])

# Define where those corners should be in the "fixed" image
dst_points = np.float32([[0, 0], [400, 0], [400, 500], [0, 500]])

# Compute the homography matrix
homography, _ = cv2.findHomography(src_points, dst_points)

# Warp the image to fix the perspective
fixed_image = cv2.warpPerspective(image, homography, (400, 500))

# Display the original and fixed images
cv2.imshow("Original", image)
cv2.imshow("Fixed", fixed_image)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

**What‚Äôs happening?**
1. We pick **4 corners** of the document in the tilted photo (`src_points`).
2. We define where those corners **should be** in a straight photo (`dst_points`).
3. `cv2.findHomography()` calculates the **magic matrix** to warp the image.
4. `cv2.warpPerspective()` applies the warp and **fixes the perspective**!

**Challenge:**
Try this with a photo of a **whiteboard** or **receipt**!

---

### **3Ô∏è‚É£ Create a "Mini 3D World" (Like a Video Game)**
Let‚Äôs use **perspective projection** to draw a **3D cube** on a 2D screen.

```python
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# Define the 8 corners of a cube in 3D space
cube = np.array([
    [0, 0, 0],  # Bottom-back-left
    [1, 0, 0],  # Bottom-front-left
    [1, 1, 0],  # Bottom-front-right
    [0, 1, 0],  # Bottom-back-right
    [0, 0, 1],  # Top-back-left
    [1, 0, 1],  # Top-front-left
    [1, 1, 1],  # Top-front-right
    [0, 1, 1]   # Top-back-right
])

# Define the edges (which corners are connected)
edges = [
    [0, 1], [1, 2], [2, 3], [3, 0],  # Bottom face
    [4, 5], [5, 6], [6, 7], [7, 4],  # Top face
    [0, 4], [1, 5], [2, 6], [3, 7]   # Vertical edges
]

# Create a 3D plot
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

# Plot the cube
for edge in edges:
    ax.plot3D(*zip(cube[edge[0]], cube[edge[1]]), color="blue")

# Set the axis limits
ax.set_xlim([0, 1])
ax.set_ylim([0, 1])
ax.set_zlim([0, 1])

# Show the plot
plt.title("3D Cube (Projected onto 2D Screen)")
plt.show()
```

**What‚Äôs happening?**
- We define a **cube** with 8 corners in 3D space.
- We draw **lines** between the corners to make the edges.
- `matplotlib` **projects** the 3D cube onto a 2D screen (just like a camera!).

**Challenge:**
Try **rotating the cube** by changing the coordinates!

---

### **4Ô∏è‚É£ Augmented Reality (AR) - Place a 3D Object in a Photo**
Let‚Äôs use **homography** to place a **virtual object** (like a 3D cube) in a photo.

```python
import cv2
import numpy as np

# Load the image
image = cv2.imread("table.jpg")

# Define 4 points on the table (where we want to place the object)
# Format: [[x1, y1], [x2, y2], [x3, y3], [x4, y4]]
table_points = np.float32([[100, 100], [300, 100], [300, 300], [100, 300]])

# Define the size of the object (in pixels)
object_size = 200

# Define where the object should be placed in 3D space
# (We'll project it onto the table)
dst_points = np.float32([
    [0, 0], [object_size, 0], [object_size, object_size], [0, object_size]
])

# Compute the homography matrix
homography, _ = cv2.findHomography(dst_points, table_points)

# Create a "virtual object" (a red square)
object_img = np.zeros((object_size, object_size, 3), dtype=np.uint8)
object_img[:] = (0, 0, 255)  # Red color

# Warp the object onto the table
warped_object = cv2.warpPerspective(object_img, homography, (image.shape[1], image.shape[0]))

# Blend the warped object with the original image
result = cv2.addWeighted(image, 1, warped_object, 0.5, 0)

# Display the result
cv2.imshow("AR Table", result)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

**What‚Äôs happening?**
1. We pick **4 points** on the table in the photo (`table_points`).
2. We define a **virtual object** (a red square) and where it should go (`dst_points`).
3. `cv2.findHomography()` calculates how to **warp** the object onto the table.
4. `cv2.warpPerspective()` **projects** the object onto the photo.
5. `cv2.addWeighted()` blends the object with the original image.

**Challenge:**
Try replacing the red square with a **3D cube** or a **Pok√©mon**!

---

## üéØ **Challenge Time!**
### **Challenge 1: Build a "Perspective Corrector" App**
Use **homography** to:
1. Let the user **click 4 corners** of a document in a photo.
2. **Warp the image** to make the document look straight.
3. Save the **fixed image**.

**Hint:**
Use `cv2.setMouseCallback()` to let the user click points.

---

### **Challenge 2: Create a "Mini 3D Game"**
Use **perspective projection** to:
1. Draw a **3D maze** on a 2D screen.
2. Let the user **navigate** through the maze with keyboard controls.

**Hint:**
Use `matplotlib` or `pygame` for the game loop.

---

### **Challenge 3: Build an AR Business Card**
Use **homography** to:
1. Take a photo of a **business card**.
2. **Overlay** a 3D model (like a rotating cube) on top of it.
3. Save the **AR business card** as a video.

**Hint:**
Use `cv2.VideoWriter()` to save the video.

---

## üìö **Summary**
In this lecture, you learned:
1. **Homogeneous coordinates**: Adding a 4th dimension to make math easier.
2. **Perspective projection**: How cameras "squish" 3D points into 2D photos.
3. **Homography**: The "unsquish" tool for fixing perspective.
4. **How to apply this in real life**: Fixing tilted photos, creating AR effects, and drawing 3D objects.

---

## üöÄ **What‚Äôs Next?**
In **Lecture 3**, we‚Äôll dive into **Pattern Recognition** teaching computers to **spot shapes, faces, and even your doodles**! We‚Äôll use **machine learning** to make computers **smarter** at recognizing patterns.

**Ready to level up?** Let‚Äôs go! üöÄ